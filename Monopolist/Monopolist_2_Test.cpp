//
//  PrincipalAgent_Test.h
//  CGalTest
//
//  Created by Jean-Marie Mirebeau on 11/02/2015.
//  Copyright (c) 2015 Jean-Marie Mirebeau. All rights reserved.
//

#include <fstream>


#include "Headers/PrincipalAgent_2.h"
#include "Headers/ConvexityConstraint_2.h"
#include "Headers/ElementaryConstraints.h"
#include "Headers/LipschitzConstraint_2.h"
#include "Headers/ElementaryShapes_2.h"


namespace PrincipalAgent_Test {
    using namespace Geometry_2;
	typedef std::vector<CGT::Full_point> PointSet;


    /** %%%%%%%%%%%%%%%% Standard Principal Agent (also called monopolist) %%%%%%%%%%%%%%%%%
	 Minimise
	 int_Omega u + (1/2) |grad u- x|^2
	 subject to
	 u non-negative, convex.
	 
	 Input : a point set, as generated by MakeShape, and an identifier for the output.
	 Output : written to files.
	 
	 
	 !! TODO !! Introduce convexity constraints for the boundary points.
	 */
	void Monopolist(const PointSet & pts, std::string filename){
        std::ofstream os;

		// Generate the domain mesh, and setup the convexity constraints
        ConvexityConstraint cvx(pts);
        PositivityConstraint pos;
        std::vector<NS::Functionnal*> constraints = {&cvx, &pos}; //


        // Generate an initial guess, as a parabola, and check the convexity constraint
        std::vector<ScalarType> x;
        for(auto p : cvx.GetPts()) x.push_back(CGT::Parabola(p.first));
        
        cvx.SetValues(x);
        /*cvx.Compute(31);
        std::cout ExportVarArrow(cvx.error) ExportVarArrow(cvx.logSum) << "\n";
        
        os.open("cvxTest.txt");
        os << "{" ExportVarArrow(cvx) << "}";
        os.close();
		*/
		
		// Setup the objective functional int_Omega u + (1/2) |grad u- x|^2
        PrincipalAgent pa;
        pa.rt = cvx.rt; // Hope this is a true deep copy.
        
        NS::NewtonConstrained newton;
        newton.maxIter=50;
        
        /*
        newton.multiplier = 2.e-5;
        newton.opt.sDelta.stopBelow = 1e-4;
         */
        
        newton.multiplier = 1./x.size();
        newton.multiplierBound *= newton.multiplier; // Vanishing constraint penalisation
//        newton.multiplierBound = newton.multiplier; // Fixed penality

        NS::VectorType xx(x.size());
        for(int i=0; i<x.size(); ++i) xx[i]=x[i];
                
        newton.Solve(pa,xx,constraints);
        
        cvx.Compute(31);
        pos.Compute(31);
        
//        const std::string filename =
//        "PA0_"+enumToRealString(shape)+".txt";
        os.open(filename);
        os << "{"
        ExportVarArrow(newton)
        ExportVarArrow(pa)
        ExportVarArrow(cvx)
        ExportVarArrow(pos)
        ExportArrayArrow(x)
        << "}";
        
        std::cout
        ExportVarArrow(newton)
        << "\n";
    }
    
    
    // %%%%%%%%%%%%%%%% A basic optimization test -- unused %%%%%%%%%%%%%%%%
    
    struct TestFunction : ConstraintType {
        virtual void SetValues(const std::vector<ScalarType> & x_){
            x = x_[0];
            error=0;
        }
        
        virtual void Compute(FlagType r) {
            if(r & RLogSum) logSum = 0.5*x*x;
            if(r & RLogGrad) {logGrad.resize(1); logGrad[0] = x;}
            if(r & RLogHessian){logHessian.resize(1); logHessian[0] = {0,0,1};}
        };
        ScalarType x;
    };
    
    void Opt0(){
        const int n=1;
        TestFunction pb;
        PositivityConstraint pos;
        std::vector<NS::Functionnal*> constraints = {&pos};
        NS::NewtonConstrained newton;
        newton.multiplier=1;
        newton.multiplierBound=1e-4; // Only one step
        
        NS::VectorType xx(n);
        xx[0]=2;
        newton.Solve(pb,xx,constraints);
        
        std::ofstream os;
        os.open("Opt0.txt");
        os << "{"
        ExportVarArrow(newton)
        ExportVarArrow(pos)
        ExportVarArrow(xx[0])
        << "}";
    }

    
    
    
    // %%%%%%%%%%%%%%%%%%%% Principal agent with refinement %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    void PA1(std::vector<CGT::Full_point> pts, int nRefine, std::string file = "PA1"){
        PrincipalAgent pa;
        pa.rt = CGT::RT(pts.begin(),pts.end());
        pa.rt.infinite_vertex()->info() = {InfiniteIndex, -1};
        std::ofstream os;
        
        for(int iRefine = 0; iRefine < nRefine; ++iRefine){
            
            ConvexityConstraint cvx(pts);
            PositivityConstraint pos;
            std::vector<NS::Functionnal*> constraints = {&cvx, &pos}; //
            
            NS::NewtonConstrained newton;
            newton.maxIter=50;

            newton.multiplier = 1./pts.size();
            newton.multiplierBound *= newton.multiplier;
            
            NS::VectorType x(pts.size());
            for(int i=0; i<x.size(); ++i) x[i]=CGT::Parabola(pts[i].first);
            
            cvx.SetValues(NS::StdFromEigen(x));
            cvx.Compute(31);
            os.open("cvxTest.txt");
            os << "{" ExportVarArrow(cvx) << "}";
            os.close();

            
            newton.Solve(pa,x,constraints);
            
            cvx.Compute(31);
            pos.Compute(31);
            
            const std::string filename = file+"_iter"+std::to_string(iRefine)+".txt";
            os.open(filename);
            os << "{"
            ExportVarArrow(newton)
            ExportVarArrow(pa)
            ExportVarArrow(cvx)
            ExportVarArrow(pos)
            ExportArrayArrow(NS::StdFromEigen(x))
            << "}";
            os.close();
            
            std::cout
            ExportVarArrow(newton)
            << "\n";
            
            // Checking error indicators, gradients
            
            
            
            std::cout << "Points before refinement : " ExportVarArrow(pa.Pts().size());
            const ScalarType refinementQuantile = 0.3;
            pa.Refine(refinementQuantile,x);
            pts = pa.Pts();
            std::cout ExportVarArrow(pts.size()) << "\n";
        }
    }
    
    struct {
        ScalarType operator()(const CGT::Point & p){
            const CGT::Vector v = p-CGT::Point(1,1);
            return std::max( 0., v.squared_length()-0.8);
        }
    } testFunc;
    
    void Ref0(int nRefine, int startSize=10){
        std::vector<CGT::Full_point> pts = MakeShape(startSize,ShapeType::Square);
        PrincipalAgent pa;
        pa.rt = CGT::RT(pts.begin(),pts.end());
        pa.rt.infinite_vertex()->info() = {InfiniteIndex, -1};
        std::ofstream os;
        os.open("Ref0.txt"); os << "{";
        
        for(int iRefine=0; iRefine<nRefine; ++iRefine){
            NS::VectorType x(pts.size());
            for(int i=0; i<pts.size(); ++i)
                x[i] = testFunc(pts[i].first.point());
            pa.Refine(0.3,x);
            pts = pa.Pts();
            
            // Also check Lipschitz regularity
            LipschitzConstraint lip(pts);
            
            os << '"' << "iter" << iRefine << '"' << "-> {"
            ExportVarArrow(pa)
            ExportVarArrow(lip)
            << "},";
        }
        os << "}";
        
    }
    
/** Linear principal agent (monopolist) problem.
 Minimise
 int_Omega u - <grad u,x>
 subject to
 u non-negative, convex, grad u in [0,1]^2
 
 Input : a point set, as generated by MakeShape, and an identifier for the output.
 Output : written to files.

*/
    void PALinear(std::vector<CGT::Full_point> pts, int nRefine, std::string file = "PALinear"){
        PrincipalAgent pa;
        pa.rt = CGT::RT(pts.begin(),pts.end());
        pa.rt.infinite_vertex()->info() = {InfiniteIndex, -1};
        std::ofstream os;
//        pa.hasQuadraticCost=false;
        
        for(int iRefine = 0; iRefine < nRefine; ++iRefine){
            
            ConvexityConstraint cvx(pts);
            PositivityConstraint pos;
            LipschitzConstraint lip(pts);
            lip.lastOfLineOnly = false;
            std::vector<NS::Functionnal*> constraints = {&cvx, &pos, &lip}; //, &lip
            
            NS::NewtonConstrained newton; //newton.verbose=true;
            newton.maxIter=50;
//            newton.opt.solverStrategy = NS::NewtonUnconstrained::SolverType::ConjugateGradient;
            newton.opt.solverStrategy = NS::NewtonUnconstrained::SolverType::Other;
            
            newton.multiplier = 1./pts.size();
            newton.multiplierBound *= newton.multiplier;
            newton.multiplierDamping = 0.7;
            
            NS::VectorType x(pts.size());
            for(int i=0; i<x.size(); ++i) x[i]=CGT::Parabola(pts[i].first)/10.;
            
            cvx.SetValues(NS::StdFromEigen(x));
            lip.SetValues(NS::StdFromEigen(x));
            cvx.Compute(31);
            lip.Compute(31);
            os.open("cvxTest.txt");
            os << "{" ExportVarArrow(cvx) ExportVarArrow(lip) << "}";
            os.close();
            
            
            newton.Solve(pa,x,constraints);
            
            cvx.Compute(31);
            pos.Compute(31);
            lip.Compute(31);
            
            const std::string filename = file+"_iter"+std::to_string(iRefine)+".txt";
            os.open(filename);
            os << "{"
            ExportVarArrow(newton)
            ExportVarArrow(pa)
            ExportVarArrow(cvx)
            ExportVarArrow(lip)
            ExportVarArrow(pos)
            ExportArrayArrow(NS::StdFromEigen(x))
            << "}";
            os.close();
            
            std::cout
            ExportVarArrow(newton)
            << "\n";
            
            // Checking error indicators, gradients
            
            
            
            std::cout << "Points before refinement : " ExportVarArrow(pa.Pts().size());
            const ScalarType refinementQuantile = 0.3;
            pa.Refine(refinementQuantile,x);
            pts = pa.Pts();
            std::cout ExportVarArrow(pts.size()) << "\n";
        }
    }

}


int main(int argc, const char * argv[]){
	
	// Example input args : 30 Triangle 0. 1. 1., see arguments description below
	--argc; ++argv; // The first argument, executable name, can be ignored.
	// Output filename repeats the arguments.
	std::ostringstream filename; filename << "Monopolist";
	for(int i=0; i<argc; ++i) filename << "_" << argv[i];
	filename << ".txt";

	// Import all arguments
	using namespace Geometry_2;
	const int n = argc-->0 ? atoi(*argv++) : 30;
	const ShapeType shape   = argc-->0 ? enumFromString<ShapeType>(*argv++) : ShapeType::Triangle;
	const ScalarType theta  = argc-->0 ? atof(*argv++) : 0.;
	const ScalarType bary_x = argc-->0 ? atof(*argv++) : Infinity;
	const ScalarType bary_y = argc-->0 ? atof(*argv++) : Infinity;

//	std::string filename = "Monopolist_"+std::to_string(n)+"_"+enumToRealString(shape)+".txt";
	PrincipalAgent_Test::Monopolist(MakeShape(n,shape,theta,{bary_x,bary_y}),filename.str());
	
///	PrincipalAgent_Test::PA0(30 , PrincipalAgent_Test::ShapeType::Triangle);
		
/*
	PrincipalAgent_Test::PA1(PrincipalAgent_Test::MakeShape(5 , PrincipalAgent_Test::ShapeType::Square),
								 8, "PA1_Triangle_2");

		
	PrincipalAgent_Test::PALinear(PrincipalAgent_Test::MakeShape(10,PrincipalAgent_Test::ShapeType::Square),
								 1, "PARef_Square_Linear");
*/

		
		
	//    PrincipalAgent_Test::Ref0(6);
	//    PrincipalAgent_Test::Ref0(3,3);
		
	//    PrincipalAgent_Test::Opt0();
	
}
